-- =============================================================================
-- PROJETO RIDE-SHARING - BACKUP COMPLETO DO BANCO DE DADOS
-- =============================================================================
-- Este arquivo contém todo o schema necessário para recriar o banco de dados
-- do projeto de compartilhamento de caronas com rastreamento em tempo real.
-- Atualizado em: 2025-01-29
-- =============================================================================

-- =============================================================================
-- EXTENSÕES NECESSÁRIAS
-- =============================================================================

-- Extensão para UUID
CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA extensions;

-- Extensão para funções criptográficas
CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA extensions;

-- Extensão para cron jobs
CREATE EXTENSION IF NOT EXISTS "pg_cron" WITH SCHEMA extensions;

-- =============================================================================
-- TIPOS CUSTOMIZADOS
-- =============================================================================

-- Tipo para status de pagamento de motoristas
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payout_status') THEN
    CREATE TYPE public.payout_status AS ENUM ('pending', 'approved', 'rejected', 'paid');
  END IF;
END $$;

-- Tipo para status de taxas de motoristas
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'fee_status') THEN
    CREATE TYPE public.fee_status AS ENUM ('not_requested', 'pending', 'paid', 'canceled', 'expired');
  END IF;
END $$;

-- Tipo para status de assinaturas
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'subscription_status') THEN
    CREATE TYPE public.subscription_status AS ENUM ('ativa', 'vencida', 'cancelada', 'pendente');
  END IF;
END $$;

-- =============================================================================
-- FUNÇÕES UTILITÁRIAS
-- =============================================================================

-- Função para atualizar timestamp automaticamente
CREATE OR REPLACE FUNCTION public.set_updated_at()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NEW IS DISTINCT FROM OLD THEN
    NEW.updated_at = NOW();
  END IF;
  RETURN NEW;
END;
$$;

-- Função para criar perfil automaticamente quando usuário é criado
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, user_type, is_active, created_at, updated_at)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'full_name', 'Usuário'),
    COALESCE(NEW.raw_user_meta_data->>'user_type', 'passenger'),
    -- Mototaxistas precisam ser aprovados, então começam inativos
    CASE 
      WHEN COALESCE(NEW.raw_user_meta_data->>'user_type', 'passenger') = 'driver' THEN FALSE
      ELSE TRUE
    END,
    NOW(),
    NOW()
  )
  ON CONFLICT (id) DO NOTHING;
  RETURN NEW;
END;
$$;

-- Função do sistema BD_ATIVO - inserir 3 registros com pausa de 5s
CREATE OR REPLACE FUNCTION public.inserir_3x_e_parar()
RETURNS VOID 
LANGUAGE plpgsql 
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  i INT := 0;
BEGIN
  WHILE i < 3 LOOP
    INSERT INTO bd_ativo(num) VALUES (1);
    i := i + 1;
    IF i < 3 THEN
      PERFORM pg_sleep(5);
    END IF;
  END LOOP;
END;
$$;

-- Função para calcular saldo do motorista
CREATE OR REPLACE FUNCTION public.calculate_driver_balance(p_driver_id uuid)
RETURNS driver_balances
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_total_earnings NUMERIC DEFAULT 0;
  v_reserved NUMERIC DEFAULT 0;
  v_available NUMERIC DEFAULT 0;
  v_balance RECORD;
BEGIN
  -- Calcular ganhos totais de corridas completadas
  SELECT COALESCE(SUM(actual_price), 0) INTO v_total_earnings
  FROM public.rides
  WHERE driver_id = p_driver_id AND status = 'completed';

  -- Calcular valor reservado para taxas pendentes
  SELECT COALESCE(SUM(actual_fee_amount), 0) INTO v_reserved
  FROM public.fee_payments
  WHERE driver_id = p_driver_id AND status IN ('pending', 'expired');

  -- Calcular disponível
  v_available := v_total_earnings - v_reserved;

  -- Garantir que não seja negativo
  IF v_available < 0 THEN
    v_available := 0;
  END IF;

  -- Inserir ou atualizar saldo
  INSERT INTO public.driver_balances (driver_id, total_earnings, available, reserved)
  VALUES (p_driver_id, v_total_earnings, v_available, v_reserved)
  ON CONFLICT (driver_id) DO UPDATE SET
    total_earnings = EXCLUDED.total_earnings,
    available = EXCLUDED.available,
    reserved = EXCLUDED.reserved,
    updated_at = NOW()
  RETURNING * INTO v_balance;

  RETURN v_balance;
END;
$$;

-- Função para solicitar pagamento de taxa
CREATE OR REPLACE FUNCTION public.request_fee_payment()
RETURNS fee_payments
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_driver_id UUID;
  v_profile_created_at TIMESTAMPTZ;
  v_initial_deadline TIMESTAMPTZ;
  v_payment_deadline TIMESTAMPTZ;
  v_available_balance NUMERIC;
  v_service_fee_settings RECORD;
  v_service_fee_amount NUMERIC;
  v_fee_payment RECORD;
BEGIN
  -- Verificar autenticação
  v_driver_id := auth.uid();
  IF v_driver_id IS NULL THEN
    RAISE EXCEPTION 'not_authenticated';
  END IF;

  -- Verificar se é motorista
  IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = v_driver_id AND user_type = 'driver') THEN
    RAISE EXCEPTION 'not_a_driver';
  END IF;

  -- Buscar data de criação do perfil
  SELECT created_at INTO v_profile_created_at
  FROM public.profiles
  WHERE id = v_driver_id;

  -- Calcular prazo inicial (2 dias após cadastro)
  v_initial_deadline := v_profile_created_at + INTERVAL '2 days';
  
  -- Verificar se ainda está dentro do prazo inicial
  IF NOW() > v_initial_deadline THEN
    RAISE EXCEPTION 'initial_deadline_expired';
  END IF;

  -- Verificar se já tem taxa pendente ou expirada
  IF EXISTS (
    SELECT 1 FROM public.fee_payments
    WHERE driver_id = v_driver_id
      AND status IN ('pending', 'expired')
  ) THEN
    RAISE EXCEPTION 'active_fee_exists';
  END IF;

  -- Buscar saldo disponível
  SELECT COALESCE(available, 0) INTO v_available_balance
  FROM public.driver_balances
  WHERE driver_id = v_driver_id;

  -- Se não existe, não há saldo disponível
  IF v_available_balance IS NULL THEN
    v_available_balance := 0;
  END IF;

  -- Verificar se tem saldo disponível
  IF v_available_balance <= 0 THEN
    RAISE EXCEPTION 'no_available_funds';
  END IF;

  -- Buscar configurações da taxa de serviço
  SELECT service_fee_type, service_fee_value
  INTO v_service_fee_settings
  FROM public.pricing_settings
  ORDER BY created_at DESC
  LIMIT 1;

  -- Calcular valor da taxa
  IF v_service_fee_settings.service_fee_type = 'fixed' THEN
    v_service_fee_amount := COALESCE(v_service_fee_settings.service_fee_value, 0);
  ELSIF v_service_fee_settings.service_fee_type = 'percent' THEN
    v_service_fee_amount := v_available_balance * (COALESCE(v_service_fee_settings.service_fee_value, 0) / 100);
  ELSE
    v_service_fee_amount := 0;
  END IF;

  -- Verificar se a taxa é válida
  IF v_service_fee_amount <= 0 THEN
    RAISE EXCEPTION 'invalid_fee_amount';
  END IF;

  -- Verificar se tem saldo suficiente para a taxa
  IF v_available_balance < v_service_fee_amount THEN
    RAISE EXCEPTION 'insufficient_funds_for_fee';
  END IF;

  -- Calcular prazo de pagamento (2 dias a partir de agora)
  v_payment_deadline := NOW() + INTERVAL '2 days';

  -- Criar solicitação de taxa
  INSERT INTO public.fee_payments (
    driver_id,
    amount,
    status,
    initial_due_date,
    payment_due_date,
    available_balance_before,
    actual_fee_amount
  ) VALUES (
    v_driver_id,
    v_available_balance,
    'pending',
    v_initial_deadline,
    v_payment_deadline,
    v_available_balance,
    v_service_fee_amount
  ) RETURNING * INTO v_fee_payment;

  -- Atualizar saldo do motorista (reservar valor da taxa)
  INSERT INTO public.driver_balances (driver_id, total_earnings, available, reserved)
  VALUES (v_driver_id, v_available_balance, 0, v_service_fee_amount)
  ON CONFLICT (driver_id) DO UPDATE SET
    available = v_available_balance - v_service_fee_amount,
    reserved = driver_balances.reserved + v_service_fee_amount,
    updated_at = NOW();

  RETURN v_fee_payment;
END;
$$;

-- Função para marcar taxa como paga
CREATE OR REPLACE FUNCTION public.mark_fee_paid(p_fee_id uuid)
RETURNS fee_payments
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_fee_payment RECORD;
  v_current_user_id UUID;
BEGIN
  -- Verificar autenticação
  v_current_user_id := auth.uid();
  IF v_current_user_id IS NULL THEN
    RAISE EXCEPTION 'unauthorized';
  END IF;

  -- Verificar se é admin
  IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = v_current_user_id AND user_type = 'admin') THEN
    RAISE EXCEPTION 'unauthorized';
  END IF;

  -- Buscar a solicitação de taxa
  SELECT * INTO v_fee_payment
  FROM public.fee_payments
  WHERE id = p_fee_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'fee_not_found';
  END IF;

  -- Verificar se está em status válido
  IF v_fee_payment.status != 'pending' THEN
    RAISE EXCEPTION 'invalid_status';
  END IF;

  -- Marcar como paga
  UPDATE public.fee_payments
  SET 
    status = 'paid',
    paid_at = NOW(),
    updated_at = NOW()
  WHERE id = p_fee_id
  RETURNING * INTO v_fee_payment;

  -- Remover valor reservado do saldo do motorista
  UPDATE public.driver_balances
  SET 
    reserved = reserved - v_fee_payment.actual_fee_amount,
    updated_at = NOW()
  WHERE driver_id = v_fee_payment.driver_id;

  RETURN v_fee_payment;
END;
$$;

-- Função para cancelar taxa
CREATE OR REPLACE FUNCTION public.cancel_fee(p_fee_id uuid, p_reason text)
RETURNS fee_payments
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_fee_payment RECORD;
  v_current_user_id UUID;
BEGIN
  -- Verificar autenticação
  v_current_user_id := auth.uid();
  IF v_current_user_id IS NULL THEN
    RAISE EXCEPTION 'unauthorized';
  END IF;

  -- Verificar se é admin
  IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = v_current_user_id AND user_type = 'admin') THEN
    RAISE EXCEPTION 'unauthorized';
  END IF;

  -- Buscar a solicitação de taxa
  SELECT * INTO v_fee_payment
  FROM public.fee_payments
  WHERE id = p_fee_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'fee_not_found';
  END IF;

  -- Verificar se está em status válido
  IF v_fee_payment.status NOT IN ('pending', 'expired') THEN
    RAISE EXCEPTION 'invalid_status';
  END IF;

  -- Cancelar a taxa
  UPDATE public.fee_payments
  SET 
    status = 'canceled',
    canceled_at = NOW(),
    canceled_reason = p_reason,
    updated_at = NOW()
  WHERE id = p_fee_id
  RETURNING * INTO v_fee_payment;

  -- Devolver valor reservado para saldo disponível
  UPDATE public.driver_balances
  SET 
    available = available + v_fee_payment.actual_fee_amount,
    reserved = reserved - v_fee_payment.actual_fee_amount,
    updated_at = NOW()
  WHERE driver_id = v_fee_payment.driver_id;

  RETURN v_fee_payment;
END;
$$;

-- Função para solicitar renovação de assinatura
CREATE OR REPLACE FUNCTION public.request_subscription_renewal(p_plan_id uuid)
RETURNS subscription_requests
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_driver_id UUID;
  v_current_subscription RECORD;
  v_plan RECORD;
  v_request RECORD;
BEGIN
  -- Verificar autenticação
  v_driver_id := auth.uid();
  IF v_driver_id IS NULL THEN
    RAISE EXCEPTION 'not_authenticated';
  END IF;

  -- Verificar se é motorista
  IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = v_driver_id AND user_type = 'driver') THEN
    RAISE EXCEPTION 'not_a_driver';
  END IF;

  -- Verificar se já tem solicitação pendente
  IF EXISTS (
    SELECT 1 FROM public.subscription_requests
    WHERE driver_id = v_driver_id AND status = 'pending'
  ) THEN
    RAISE EXCEPTION 'pending_request_exists';
  END IF;

  -- Buscar plano
  SELECT * INTO v_plan
  FROM public.subscription_plans
  WHERE id = p_plan_id AND is_active = true;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'invalid_plan';
  END IF;

  -- Buscar assinatura atual (se houver)
  SELECT * INTO v_current_subscription
  FROM public.driver_subscriptions
  WHERE driver_id = v_driver_id
  ORDER BY created_at DESC
  LIMIT 1;

  -- Criar solicitação
  INSERT INTO public.subscription_requests (
    driver_id,
    plan_id,
    current_subscription_id,
    status
  ) VALUES (
    v_driver_id,
    p_plan_id,
    v_current_subscription.id,
    'pending'
  ) RETURNING * INTO v_request;

  RETURN v_request;
END;
$$;

-- Função para aprovar pagamento de assinatura
CREATE OR REPLACE FUNCTION public.approve_subscription_payment(p_request_id uuid)
RETURNS driver_subscriptions
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_id UUID;
  v_request RECORD;
  v_plan RECORD;
  v_current_subscription RECORD;
  v_start_date TIMESTAMPTZ;
  v_end_date TIMESTAMPTZ;
  v_new_subscription RECORD;
BEGIN
  -- Verificar autenticação admin
  v_admin_id := auth.uid();
  IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = v_admin_id AND user_type = 'admin') THEN
    RAISE EXCEPTION 'unauthorized';
  END IF;

  -- Buscar solicitação
  SELECT * INTO v_request
  FROM public.subscription_requests
  WHERE id = p_request_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'request_not_found';
  END IF;

  IF v_request.status != 'pending' THEN
    RAISE EXCEPTION 'invalid_request_status';
  END IF;

  -- Buscar plano
  SELECT * INTO v_plan
  FROM public.subscription_plans
  WHERE id = v_request.plan_id;

  -- Buscar assinatura atual (se houver)
  SELECT * INTO v_current_subscription
  FROM public.driver_subscriptions
  WHERE driver_id = v_request.driver_id
  ORDER BY created_at DESC
  LIMIT 1;

  -- Calcular datas
  IF v_current_subscription.id IS NOT NULL AND v_current_subscription.end_date > NOW() THEN
    -- Renovação antecipada: soma ao final do período atual
    v_start_date := v_current_subscription.end_date;
    v_end_date := v_current_subscription.end_date + (v_plan.duration_days || ' days')::interval;
  ELSE
    -- Nova assinatura ou assinatura vencida
    v_start_date := NOW();
    v_end_date := NOW() + (v_plan.duration_days || ' days')::interval;
  END IF;

  -- Criar nova assinatura
  INSERT INTO public.driver_subscriptions (
    driver_id,
    plan_id,
    status,
    start_date,
    end_date
  ) VALUES (
    v_request.driver_id,
    v_request.plan_id,
    'ativa',
    v_start_date,
    v_end_date
  ) RETURNING * INTO v_new_subscription;

  -- Atualizar solicitação
  UPDATE public.subscription_requests
  SET 
    status = 'approved',
    processed_at = NOW(),
    processed_by = v_admin_id
  WHERE id = p_request_id;

  -- Marcar assinatura anterior como inativa (se houver)
  IF v_current_subscription.id IS NOT NULL THEN
    UPDATE public.driver_subscriptions
    SET status = 'vencida'
    WHERE id = v_current_subscription.id;
  END IF;

  RETURN v_new_subscription;
END;
$$;

-- Função para obter status da assinatura do motorista
CREATE OR REPLACE FUNCTION public.get_driver_subscription_status(p_driver_id uuid)
RETURNS TABLE(subscription_id uuid, plan_name text, duration_days integer, price_cents integer, status subscription_status, start_date timestamp with time zone, end_date timestamp with time zone, days_remaining integer, has_pending_request boolean)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ds.id as subscription_id,
    sp.name as plan_name,
    sp.duration_days,
    sp.price_cents,
    CASE 
      WHEN ds.end_date < NOW() THEN 'vencida'::subscription_status
      ELSE ds.status
    END as status,
    ds.start_date,
    ds.end_date,
    GREATEST(0, EXTRACT(DAY FROM ds.end_date - NOW())::INTEGER) as days_remaining,
    EXISTS(
      SELECT 1 FROM public.subscription_requests sr 
      WHERE sr.driver_id = p_driver_id AND sr.status = 'pending'
    ) as has_pending_request
  FROM public.driver_subscriptions ds
  JOIN public.subscription_plans sp ON sp.id = ds.plan_id
  WHERE ds.driver_id = p_driver_id
  ORDER BY ds.created_at DESC
  LIMIT 1;
END;
$$;

-- =============================================================================
-- TABELAS PRINCIPAIS
-- =============================================================================

-- -----------------------------------------------------------------------------
-- Tabela: profiles (Perfis de usuários)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID NOT NULL PRIMARY KEY,
  full_name TEXT NOT NULL,
  phone TEXT,
  user_type TEXT NOT NULL, -- 'passenger', 'driver', 'admin'
  avatar_url TEXT,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- -----------------------------------------------------------------------------
-- Tabela: admin_setup (Configuração inicial do admin)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.admin_setup (
  admin_user_id UUID NOT NULL PRIMARY KEY,
  password_set BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- -----------------------------------------------------------------------------
-- Tabela: driver_details (Detalhes dos motoristas)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.driver_details (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  user_id UUID NOT NULL,
  vehicle_type TEXT DEFAULT 'car',
  vehicle_brand TEXT,
  vehicle_model TEXT,
  vehicle_color TEXT,
  vehicle_plate TEXT,
  driver_license TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- -----------------------------------------------------------------------------
-- Tabela: pricing_settings (Configurações de preços)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.pricing_settings (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  price_per_km NUMERIC DEFAULT 2.50,
  fixed_price NUMERIC,
  price_per_km_active BOOLEAN DEFAULT TRUE,
  fixed_price_active BOOLEAN DEFAULT FALSE,
  service_fee_type TEXT DEFAULT 'fixed', -- 'fixed' ou 'percent'
  service_fee_value NUMERIC DEFAULT 0,
  singleton BOOLEAN DEFAULT TRUE,
  updated_by UUID,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- -----------------------------------------------------------------------------
-- Tabela: locations (Localizações em tempo real)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.locations (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  user_id UUID NOT NULL,
  lat DOUBLE PRECISION NOT NULL,
  lng DOUBLE PRECISION NOT NULL,
  heading DOUBLE PRECISION,
  speed DOUBLE PRECISION,
  timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- -----------------------------------------------------------------------------
-- Tabela: rides (Corridas/viagens)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.rides (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  passenger_id UUID NOT NULL,
  driver_id UUID,
  origin_lat DOUBLE PRECISION NOT NULL,
  origin_lng DOUBLE PRECISION NOT NULL,
  destination_lat DOUBLE PRECISION NOT NULL,
  destination_lng DOUBLE PRECISION NOT NULL,
  estimated_duration INTEGER,
  estimated_distance DOUBLE PRECISION,
  estimated_price NUMERIC,
  actual_price NUMERIC,
  status TEXT DEFAULT 'pending', -- 'pending', 'accepted', 'in_progress', 'completed', 'cancelled'
  driver_en_route BOOLEAN DEFAULT FALSE,
  en_route_started_at TIMESTAMPTZ,
  driver_to_pickup_distance_km DOUBLE PRECISION,
  driver_to_pickup_duration_min INTEGER,
  driver_arrived BOOLEAN DEFAULT FALSE,
  pickup_arrived_at TIMESTAMPTZ,
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  payment_method TEXT,
  origin_address TEXT NOT NULL,
  destination_address TEXT NOT NULL
);

-- -----------------------------------------------------------------------------
-- Tabela: ride_ratings (Avaliações de corridas)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.ride_ratings (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  ride_id UUID NOT NULL,
  reviewer_id UUID NOT NULL,
  reviewee_id UUID NOT NULL,
  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
  comment TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- -----------------------------------------------------------------------------
-- Tabela: driver_passenger_ratings (Avaliações de motoristas para passageiros)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.driver_passenger_ratings (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  ride_id UUID NOT NULL,
  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
  created_by UUID NOT NULL,
  comment TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- -----------------------------------------------------------------------------
-- Tabela: driver_payout_requests (Solicitações de saque de motoristas)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.driver_payout_requests (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  driver_id UUID NOT NULL,
  amount NUMERIC NOT NULL,
  status public.payout_status DEFAULT 'pending',
  payment_method TEXT NOT NULL,
  payment_details JSONB NOT NULL,
  notes TEXT,
  admin_notes TEXT,
  processed_by UUID,
  processed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- -----------------------------------------------------------------------------
-- Tabela: driver_balances (Saldos dos motoristas)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.driver_balances (
  driver_id UUID NOT NULL PRIMARY KEY,
  total_earnings NUMERIC DEFAULT 0,
  available NUMERIC DEFAULT 0,
  reserved NUMERIC DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- -----------------------------------------------------------------------------
-- Tabela: fee_payments (Pagamentos de taxas)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.fee_payments (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  driver_id UUID NOT NULL,
  amount NUMERIC NOT NULL,
  status public.fee_status DEFAULT 'not_requested',
  initial_due_date TIMESTAMPTZ NOT NULL,
  payment_due_date TIMESTAMPTZ,
  paid_at TIMESTAMPTZ,
  canceled_at TIMESTAMPTZ,
  canceled_reason TEXT,
  available_balance_before NUMERIC DEFAULT 0,
  actual_fee_amount NUMERIC DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- -----------------------------------------------------------------------------
-- Tabela: chat_messages (Mensagens de chat)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.chat_messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  ride_id UUID NOT NULL,
  sender_id UUID NOT NULL,
  receiver_id UUID NOT NULL,
  text TEXT NOT NULL,
  delivered_at TIMESTAMPTZ,
  read_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- -----------------------------------------------------------------------------
-- Tabela: subscription_plans (Planos de assinatura)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.subscription_plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  duration_days INTEGER NOT NULL,
  price_cents INTEGER NOT NULL,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- -----------------------------------------------------------------------------
-- Tabela: subscription_requests (Solicitações de assinatura)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.subscription_requests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  driver_id UUID NOT NULL,
  plan_id UUID NOT NULL,
  current_subscription_id UUID,
  status TEXT DEFAULT 'pending',
  requested_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  processed_at TIMESTAMPTZ,
  processed_by UUID,
  admin_notes TEXT
);

-- -----------------------------------------------------------------------------
-- Tabela: driver_subscriptions (Assinaturas dos motoristas)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.driver_subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  driver_id UUID NOT NULL,
  plan_id UUID NOT NULL,
  status public.subscription_status DEFAULT 'ativa',
  start_date TIMESTAMPTZ NOT NULL,
  end_date TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- -----------------------------------------------------------------------------
-- Tabela: bd_ativo (Sistema de monitoramento do banco)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.bd_ativo (
  id SERIAL PRIMARY KEY,
  num BIGINT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- =============================================================================
-- ÍNDICES E CONSTRAINTS
-- =============================================================================

-- Índices para locations
CREATE UNIQUE INDEX IF NOT EXISTS locations_user_id_key ON public.locations(user_id);
CREATE INDEX IF NOT EXISTS idx_locations_user_time ON public.locations(user_id, timestamp DESC);

-- Índices para rides
CREATE INDEX IF NOT EXISTS idx_rides_passenger ON public.rides(passenger_id);
CREATE INDEX IF NOT EXISTS idx_rides_driver ON public.rides(driver_id);
CREATE INDEX IF NOT EXISTS idx_rides_status ON public.rides(status);

-- Constraint para garantir apenas uma linha ativa em pricing_settings
CREATE UNIQUE INDEX IF NOT EXISTS one_pricing_row ON public.pricing_settings (singleton) WHERE singleton;

-- =============================================================================
-- ROW LEVEL SECURITY (RLS) E POLÍTICAS
-- =============================================================================

-- Habilitar RLS em todas as tabelas
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admin_setup ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.driver_details ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.pricing_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.locations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.rides ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ride_ratings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.driver_passenger_ratings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.driver_payout_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.driver_balances ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.fee_payments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.chat_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscription_plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscription_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.driver_subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bd_ativo ENABLE ROW LEVEL SECURITY;

-- Políticas para profiles
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='profiles' AND polname='Users can insert their own profile') THEN
    CREATE POLICY "Users can insert their own profile"
      ON public.profiles
      FOR INSERT
      WITH CHECK (auth.uid() = id);
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='profiles' AND polname='Users can update their own profile') THEN
    CREATE POLICY "Users can update their own profile"
      ON public.profiles
      FOR UPDATE
      USING (auth.uid() = id);
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='profiles' AND polname='Users can view all profiles') THEN
    CREATE POLICY "Users can view all profiles"
      ON public.profiles
      FOR SELECT
      USING (TRUE);
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='profiles' AND polname='Admins can update any profile') THEN
    CREATE POLICY "Admins can update any profile"
      ON public.profiles
      FOR UPDATE
      USING (EXISTS (
        SELECT 1 FROM public.profiles admin_profiles
        WHERE admin_profiles.id = auth.uid() AND admin_profiles.user_type = 'admin'
      ));
  END IF;
END $$;

-- Políticas para admin_setup
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Admins can manage admin_setup' AND tablename='admin_setup') THEN
    CREATE POLICY "Admins can manage admin_setup"
      ON public.admin_setup
      FOR ALL
      USING (EXISTS (SELECT 1 FROM public.profiles WHERE profiles.id = auth.uid() AND profiles.user_type = 'admin'));
  END IF;
END $$;

-- Políticas para driver_details
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Drivers can manage their own details' AND tablename='driver_details') THEN
    CREATE POLICY "Drivers can manage their own details"
      ON public.driver_details
      FOR ALL
      USING (user_id = auth.uid());
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Admins can view all driver details' AND tablename='driver_details') THEN
    CREATE POLICY "Admins can view all driver details"
      ON public.driver_details
      FOR SELECT
      USING (EXISTS (SELECT 1 FROM public.profiles WHERE profiles.id = auth.uid() AND profiles.user_type = 'admin'));
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Passengers can view driver details during active rides' AND tablename='driver_details') THEN
    CREATE POLICY "Passengers can view driver details during active rides"
      ON public.driver_details
      FOR SELECT
      USING (EXISTS (
        SELECT 1 FROM public.rides
        WHERE rides.driver_id = driver_details.user_id
          AND rides.passenger_id = auth.uid()
          AND rides.status IN ('accepted', 'in_progress')
      ));
  END IF;
END $$;

-- Políticas para pricing_settings
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Admins can manage pricing settings' AND tablename='pricing_settings') THEN
    CREATE POLICY "Admins can manage pricing settings"
      ON public.pricing_settings
      FOR ALL
      USING (EXISTS (SELECT 1 FROM public.profiles WHERE profiles.id = auth.uid() AND profiles.user_type = 'admin'));
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Everyone can view pricing settings' AND tablename='pricing_settings') THEN
    CREATE POLICY "Everyone can view pricing settings"
      ON public.pricing_settings
      FOR SELECT
      USING (TRUE);
  END IF;
END $$;

-- Políticas para locations
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Users can manage their own location' AND tablename='locations') THEN
    CREATE POLICY "Users can manage their own location"
      ON public.locations
      FOR ALL
      USING (user_id = auth.uid());
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Users can view locations for active rides' AND tablename='locations') THEN
    CREATE POLICY "Users can view locations for active rides"
      ON public.locations
      FOR SELECT
      USING (EXISTS (
        SELECT 1 FROM public.rides
        WHERE ((rides.passenger_id = auth.uid()) OR (rides.driver_id = auth.uid()))
          AND rides.status IN ('accepted', 'in_progress')
          AND ((rides.driver_id = locations.user_id) OR (rides.passenger_id = locations.user_id))
      ));
  END IF;
END $$;

-- Políticas para rides
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Admins can view all rides' AND tablename='rides') THEN
    CREATE POLICY "Admins can view all rides"
      ON public.rides
      FOR SELECT
      USING (EXISTS (SELECT 1 FROM public.profiles WHERE profiles.id = auth.uid() AND profiles.user_type = 'admin'));
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Passengers can create rides' AND tablename='rides') THEN
    CREATE POLICY "Passengers can create rides"
      ON public.rides
      FOR INSERT
      WITH CHECK (passenger_id = auth.uid());
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Users can view their rides' AND tablename='rides') THEN
    CREATE POLICY "Users can view their rides"
      ON public.rides
      FOR SELECT
      USING ((passenger_id = auth.uid()) OR (driver_id = auth.uid()));
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Users can update their rides' AND tablename='rides') THEN
    CREATE POLICY "Users can update their rides"
      ON public.rides
      FOR UPDATE
      USING ((passenger_id = auth.uid()) OR (driver_id = auth.uid()) OR 
             ((driver_id IS NULL) AND (status = 'pending')));
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Drivers can view pending rides' AND tablename='rides') THEN
    CREATE POLICY "Drivers can view pending rides"
      ON public.rides
      FOR SELECT
      USING ((status = 'pending') AND 
             (EXISTS (SELECT 1 FROM public.profiles WHERE profiles.id = auth.uid() AND profiles.user_type = 'driver')));
  END IF;
END $$;

-- Políticas para ride_ratings
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Users can manage ratings for their rides' AND tablename='ride_ratings') THEN
    CREATE POLICY "Users can manage ratings for their rides"
      ON public.ride_ratings
      FOR ALL
      USING ((reviewer_id = auth.uid()) OR (reviewee_id = auth.uid()));
  END IF;
END $$;

-- Políticas para driver_passenger_ratings
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Users can manage driver passenger ratings' AND tablename='driver_passenger_ratings') THEN
    CREATE POLICY "Users can manage driver passenger ratings"
      ON public.driver_passenger_ratings
      FOR ALL
      USING ((created_by = auth.uid()) OR (EXISTS (
        SELECT 1 FROM public.rides
        WHERE rides.id = driver_passenger_ratings.ride_id
          AND ((rides.passenger_id = auth.uid()) OR (rides.driver_id = auth.uid()))
      )));
  END IF;
END $$;

-- Políticas para driver_payout_requests
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Drivers can manage their payout requests' AND tablename='driver_payout_requests') THEN
    CREATE POLICY "Drivers can manage their payout requests"
      ON public.driver_payout_requests
      FOR ALL
      USING (driver_id = auth.uid());
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Admins can view all payout requests' AND tablename='driver_payout_requests') THEN
    CREATE POLICY "Admins can view all payout requests"
      ON public.driver_payout_requests
      FOR SELECT
      USING (EXISTS (SELECT 1 FROM public.profiles WHERE profiles.id = auth.uid() AND profiles.user_type = 'admin'));
  END IF;
END $$;

-- Políticas para driver_balances
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Drivers can view their own balance' AND tablename='driver_balances') THEN
    CREATE POLICY "Drivers can view their own balance"
      ON public.driver_balances
      FOR SELECT
      USING (driver_id = auth.uid());
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='System can manage driver balances' AND tablename='driver_balances') THEN
    CREATE POLICY "System can manage driver balances"
      ON public.driver_balances
      FOR ALL
      USING (TRUE);
  END IF;
END $$;

-- Políticas para fee_payments
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Drivers can view their own fee payments' AND tablename='fee_payments') THEN
    CREATE POLICY "Drivers can view their own fee payments"
      ON public.fee_payments
      FOR SELECT
      USING (driver_id = auth.uid());
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Admins can manage fee payments' AND tablename='fee_payments') THEN
    CREATE POLICY "Admins can manage fee payments"
      ON public.fee_payments
      FOR ALL
      USING (EXISTS (SELECT 1 FROM public.profiles WHERE profiles.id = auth.uid() AND profiles.user_type = 'admin'));
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='System can manage fee payments' AND tablename='fee_payments') THEN
    CREATE POLICY "System can manage fee payments"
      ON public.fee_payments
      FOR ALL
      USING (TRUE);
  END IF;
END $$;

-- Políticas para chat_messages
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Users can view messages from their rides' AND tablename='chat_messages') THEN
    CREATE POLICY "Users can view messages from their rides"
      ON public.chat_messages
      FOR SELECT
      USING (EXISTS (
        SELECT 1 FROM public.rides
        WHERE rides.id = chat_messages.ride_id
          AND ((rides.passenger_id = auth.uid()) OR (rides.driver_id = auth.uid()))
      ));
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Users can send messages in their rides' AND tablename='chat_messages') THEN
    CREATE POLICY "Users can send messages in their rides"
      ON public.chat_messages
      FOR INSERT
      WITH CHECK (
        (sender_id = auth.uid()) AND
        (EXISTS (
          SELECT 1 FROM public.rides
          WHERE rides.id = chat_messages.ride_id
            AND ((rides.passenger_id = auth.uid()) OR (rides.driver_id = auth.uid()))
        )) AND
        (EXISTS (
          SELECT 1 FROM public.rides
          WHERE rides.id = chat_messages.ride_id
            AND ((rides.passenger_id = chat_messages.receiver_id) OR (rides.driver_id = chat_messages.receiver_id))
        ))
      );
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Users can update messages sent to them' AND tablename='chat_messages') THEN
    CREATE POLICY "Users can update messages sent to them"
      ON public.chat_messages
      FOR UPDATE
      USING (receiver_id = auth.uid())
      WITH CHECK (receiver_id = auth.uid());
  END IF;
END $$;

-- Políticas para subscription_plans
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Everyone can view active subscription plans' AND tablename='subscription_plans') THEN
    CREATE POLICY "Everyone can view active subscription plans"
      ON public.subscription_plans
      FOR SELECT
      USING (is_active = TRUE);
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Admins can manage subscription plans' AND tablename='subscription_plans') THEN
    CREATE POLICY "Admins can manage subscription plans"
      ON public.subscription_plans
      FOR ALL
      USING (EXISTS (SELECT 1 FROM public.profiles WHERE profiles.id = auth.uid() AND profiles.user_type = 'admin'));
  END IF;
END $$;

-- Políticas para subscription_requests
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Drivers can create and view their own subscription requests' AND tablename='subscription_requests') THEN
    CREATE POLICY "Drivers can create and view their own subscription requests"
      ON public.subscription_requests
      FOR ALL
      USING (driver_id = auth.uid());
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Admins can view and manage all subscription requests' AND tablename='subscription_requests') THEN
    CREATE POLICY "Admins can view and manage all subscription requests"
      ON public.subscription_requests
      FOR ALL
      USING (EXISTS (SELECT 1 FROM public.profiles WHERE profiles.id = auth.uid() AND profiles.user_type = 'admin'));
  END IF;
END $$;

-- Políticas para driver_subscriptions
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Drivers can view their own subscriptions' AND tablename='driver_subscriptions') THEN
    CREATE POLICY "Drivers can view their own subscriptions"
      ON public.driver_subscriptions
      FOR SELECT
      USING (driver_id = auth.uid());
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Admins can view all driver subscriptions' AND tablename='driver_subscriptions') THEN
    CREATE POLICY "Admins can view all driver subscriptions"
      ON public.driver_subscriptions
      FOR SELECT
      USING (EXISTS (SELECT 1 FROM public.profiles WHERE profiles.id = auth.uid() AND profiles.user_type = 'admin'));
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='System can manage driver subscriptions' AND tablename='driver_subscriptions') THEN
    CREATE POLICY "System can manage driver subscriptions"
      ON public.driver_subscriptions
      FOR ALL
      USING (TRUE);
  END IF;
END $$;

-- Políticas para bd_ativo
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='System can insert bd_ativo records' AND tablename='bd_ativo') THEN
    CREATE POLICY "System can insert bd_ativo records"
      ON public.bd_ativo
      FOR INSERT
      WITH CHECK (TRUE);
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE polname='Admins can view all bd_ativo records' AND tablename='bd_ativo') THEN
    CREATE POLICY "Admins can view all bd_ativo records"
      ON public.bd_ativo
      FOR SELECT
      USING (EXISTS (SELECT 1 FROM public.profiles WHERE profiles.id = auth.uid() AND profiles.user_type = 'admin'));
  END IF;
END $$;

-- =============================================================================
-- TRIGGERS
-- =============================================================================

-- Trigger para perfil automaticamente criado
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger
    WHERE tgname = 'on_auth_user_created' AND tgrelid = 'auth.users'::regclass
  ) THEN
    CREATE TRIGGER on_auth_user_created
      AFTER INSERT ON auth.users
      FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();
  END IF;
END $$;

-- Triggers para updated_at
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'profiles_set_updated_at') THEN
    CREATE TRIGGER profiles_set_updated_at
      BEFORE UPDATE ON public.profiles
      FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'admin_setup_set_updated_at') THEN
    CREATE TRIGGER admin_setup_set_updated_at
      BEFORE UPDATE ON public.admin_setup
      FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='driver_details_set_updated_at') THEN
    CREATE TRIGGER driver_details_set_updated_at
      BEFORE UPDATE ON public.driver_details
      FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='pricing_settings_set_updated_at') THEN
    CREATE TRIGGER pricing_settings_set_updated_at
      BEFORE UPDATE ON public.pricing_settings
      FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='rides_set_updated_at') THEN
    CREATE TRIGGER rides_set_updated_at
      BEFORE UPDATE ON public.rides
      FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='ride_ratings_set_updated_at') THEN
    CREATE TRIGGER ride_ratings_set_updated_at
      BEFORE UPDATE ON public.ride_ratings
      FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='driver_passenger_ratings_set_updated_at') THEN
    CREATE TRIGGER driver_passenger_ratings_set_updated_at
      BEFORE UPDATE ON public.driver_passenger_ratings
      FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='driver_payout_requests_set_updated_at') THEN
    CREATE TRIGGER driver_payout_requests_set_updated_at
      BEFORE UPDATE ON public.driver_payout_requests
      FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='driver_balances_set_updated_at') THEN
    CREATE TRIGGER driver_balances_set_updated_at
      BEFORE UPDATE ON public.driver_balances
      FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='fee_payments_set_updated_at') THEN
    CREATE TRIGGER fee_payments_set_updated_at
      BEFORE UPDATE ON public.fee_payments
      FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='chat_messages_set_updated_at') THEN
    CREATE TRIGGER chat_messages_set_updated_at
      BEFORE UPDATE ON public.chat_messages
      FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='subscription_plans_set_updated_at') THEN
    CREATE TRIGGER subscription_plans_set_updated_at
      BEFORE UPDATE ON public.subscription_plans
      FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='driver_subscriptions_set_updated_at') THEN
    CREATE TRIGGER driver_subscriptions_set_updated_at
      BEFORE UPDATE ON public.driver_subscriptions
      FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
  END IF;
END $$;

-- =============================================================================
-- CONFIGURAÇÕES DE REALTIME
-- =============================================================================

-- Habilitar realtime para tabelas críticas
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables 
    WHERE pubname = 'supabase_realtime' AND tablename = 'locations'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.locations;
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables 
    WHERE pubname = 'supabase_realtime' AND tablename = 'rides'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.rides;
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables 
    WHERE pubname = 'supabase_realtime' AND tablename = 'chat_messages'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.chat_messages;
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables 
    WHERE pubname = 'supabase_realtime' AND tablename = 'driver_balances'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.driver_balances;
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables 
    WHERE pubname = 'supabase_realtime' AND tablename = 'fee_payments'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.fee_payments;
  END IF;
END $$;

-- =============================================================================
-- STORAGE BUCKETS
-- =============================================================================

-- Bucket para avatars
INSERT INTO storage.buckets (id, name, public)
SELECT 'avatars', 'avatars', true
WHERE NOT EXISTS (SELECT 1 FROM storage.buckets WHERE id = 'avatars');

-- Políticas para storage de avatars
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname = 'storage' AND tablename = 'objects' 
    AND polname = 'Avatar images are publicly accessible'
  ) THEN
    CREATE POLICY "Avatar images are publicly accessible"
      ON storage.objects FOR SELECT
      USING (bucket_id = 'avatars');
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname = 'storage' AND tablename = 'objects' 
    AND polname = 'Users can upload their own avatar'
  ) THEN
    CREATE POLICY "Users can upload their own avatar"
      ON storage.objects FOR INSERT
      WITH CHECK (bucket_id = 'avatars' AND auth.uid()::text = (storage.foldername(name))[1]);
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname = 'storage' AND tablename = 'objects' 
    AND polname = 'Users can update their own avatar'
  ) THEN
    CREATE POLICY "Users can update their own avatar"
      ON storage.objects FOR UPDATE
      USING (bucket_id = 'avatars' AND auth.uid()::text = (storage.foldername(name))[1]);
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname = 'storage' AND tablename = 'objects' 
    AND polname = 'Users can delete their own avatar'
  ) THEN
    CREATE POLICY "Users can delete their own avatar"
      ON storage.objects FOR DELETE
      USING (bucket_id = 'avatars' AND auth.uid()::text = (storage.foldername(name))[1]);
  END IF;
END $$;

-- =============================================================================
-- CRON JOBS
-- =============================================================================

-- Remover cron job existente se houver
SELECT cron.unschedule('projetoAtivo');

-- Agendar cron job projetoAtivo (executa a cada 5 dias às 00:00)
SELECT cron.schedule(
  'projetoAtivo',
  '0 0 */5 * *',
  'SELECT inserir_3x_e_parar();'
);

-- =============================================================================
-- DADOS INICIAIS (SEED DATA)
-- =============================================================================

-- Dados iniciais para pricing_settings
INSERT INTO public.pricing_settings (price_per_km, fixed_price, price_per_km_active, fixed_price_active, service_fee_type, service_fee_value, singleton)
SELECT 2.50, NULL, TRUE, FALSE, 'fixed', 0, TRUE
WHERE NOT EXISTS (SELECT 1 FROM public.pricing_settings);

-- Dados iniciais para admin_setup
INSERT INTO public.admin_setup (admin_user_id, password_set)
SELECT '00000000-0000-0000-0000-000000000000', FALSE
WHERE NOT EXISTS (SELECT 1 FROM public.admin_setup);

-- =============================================================================
-- VERIFICAÇÃO FINAL
-- =============================================================================

DO $$
DECLARE
  table_count INTEGER;
  function_count INTEGER;
  trigger_count INTEGER;
  policy_count INTEGER;
  cron_count INTEGER;
BEGIN
  -- Contar tabelas criadas
  SELECT COUNT(*) INTO table_count
  FROM information_schema.tables
  WHERE table_schema = 'public'
    AND table_name IN (
      'profiles', 'admin_setup', 'driver_details', 'pricing_settings',
      'locations', 'rides', 'ride_ratings', 'driver_passenger_ratings',
      'driver_payout_requests', 'driver_balances', 'fee_payments',
      'chat_messages', 'subscription_plans', 'subscription_requests',
      'driver_subscriptions', 'bd_ativo'
    );

  -- Contar funções criadas
  SELECT COUNT(*) INTO function_count
  FROM pg_proc p
  JOIN pg_namespace n ON p.pronamespace = n.oid
  WHERE n.nspname = 'public'
    AND p.proname IN (
      'set_updated_at', 'handle_new_user', 'inserir_3x_e_parar',
      'calculate_driver_balance', 'request_fee_payment', 'mark_fee_paid',
      'cancel_fee', 'request_subscription_renewal', 'approve_subscription_payment',
      'get_driver_subscription_status'
    );

  -- Contar triggers criados
  SELECT COUNT(*) INTO trigger_count
  FROM pg_trigger
  WHERE tgname LIKE '%_set_updated_at' OR tgname = 'on_auth_user_created';

  -- Contar políticas RLS
  SELECT COUNT(*) INTO policy_count
  FROM pg_policies
  WHERE schemaname = 'public';

  -- Contar cron jobs
  SELECT COUNT(*) INTO cron_count
  FROM cron.job
  WHERE jobname = 'projetoAtivo';

  -- Exibir resultados
  RAISE NOTICE '=============================================================================';
  RAISE NOTICE 'BACKUP COMPLETO EXECUTADO COM SUCESSO!';
  RAISE NOTICE '=============================================================================';
  RAISE NOTICE 'Tabelas criadas: % de 16', table_count;
  RAISE NOTICE 'Funções criadas: % de 10+', function_count;
  RAISE NOTICE 'Triggers criados: %', trigger_count;
  RAISE NOTICE 'Políticas RLS criadas: %', policy_count;
  RAISE NOTICE 'Cron jobs agendados: %', cron_count;
  RAISE NOTICE '=============================================================================';

  -- Verificar se tudo foi criado corretamente
  IF table_count = 16 AND function_count >= 10 AND cron_count = 1 THEN
    RAISE NOTICE 'STATUS: ✅ TODOS OS COMPONENTES FORAM CRIADOS COM SUCESSO!';
  ELSE
    RAISE WARNING 'STATUS: ⚠️  ALGUNS COMPONENTES PODEM NÃO TER SIDO CRIADOS CORRETAMENTE';
  END IF;
  
  RAISE NOTICE '=============================================================================';
END $$;

-- =============================================================================
-- FIM DO BACKUP
-- =============================================================================