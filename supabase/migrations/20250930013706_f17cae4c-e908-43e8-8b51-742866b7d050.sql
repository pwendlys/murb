-- =============================================================================
-- PROJETO RIDE-SHARING - MIGRAÇÃO COMPLETA
-- =============================================================================

-- Extensões
CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA extensions;
CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA extensions;
CREATE EXTENSION IF NOT EXISTS "pg_cron" WITH SCHEMA extensions;

-- Tipos customizados
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payout_status') THEN CREATE TYPE public.payout_status AS ENUM ('pending', 'approved', 'rejected', 'paid'); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'fee_status') THEN CREATE TYPE public.fee_status AS ENUM ('not_requested', 'pending', 'paid', 'canceled', 'expired'); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'subscription_status') THEN CREATE TYPE public.subscription_status AS ENUM ('ativa', 'vencida', 'cancelada', 'pendente'); END IF; END $$;

-- Tabelas
CREATE TABLE IF NOT EXISTS public.profiles (id UUID PRIMARY KEY, full_name TEXT NOT NULL, phone TEXT, user_type TEXT NOT NULL, avatar_url TEXT, is_active BOOLEAN DEFAULT TRUE, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW());
CREATE TABLE IF NOT EXISTS public.admin_setup (admin_user_id UUID PRIMARY KEY, password_set BOOLEAN DEFAULT FALSE, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW());
CREATE TABLE IF NOT EXISTS public.driver_details (id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(), user_id UUID NOT NULL, vehicle_type TEXT DEFAULT 'car', vehicle_brand TEXT, vehicle_model TEXT, vehicle_color TEXT, vehicle_plate TEXT, driver_license TEXT, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW());
CREATE TABLE IF NOT EXISTS public.pricing_settings (id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(), price_per_km NUMERIC DEFAULT 2.50, fixed_price NUMERIC, price_per_km_active BOOLEAN DEFAULT TRUE, fixed_price_active BOOLEAN DEFAULT FALSE, service_fee_type TEXT DEFAULT 'fixed', service_fee_value NUMERIC DEFAULT 0, singleton BOOLEAN DEFAULT TRUE, updated_by UUID, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW());
CREATE TABLE IF NOT EXISTS public.locations (id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(), user_id UUID NOT NULL, lat DOUBLE PRECISION NOT NULL, lng DOUBLE PRECISION NOT NULL, heading DOUBLE PRECISION, speed DOUBLE PRECISION, timestamp TIMESTAMPTZ DEFAULT NOW());
CREATE TABLE IF NOT EXISTS public.rides (id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(), passenger_id UUID NOT NULL, driver_id UUID, origin_lat DOUBLE PRECISION NOT NULL, origin_lng DOUBLE PRECISION NOT NULL, destination_lat DOUBLE PRECISION NOT NULL, destination_lng DOUBLE PRECISION NOT NULL, estimated_duration INTEGER, estimated_distance DOUBLE PRECISION, estimated_price NUMERIC, actual_price NUMERIC, status TEXT DEFAULT 'pending', driver_en_route BOOLEAN DEFAULT FALSE, en_route_started_at TIMESTAMPTZ, driver_to_pickup_distance_km DOUBLE PRECISION, driver_to_pickup_duration_min INTEGER, driver_arrived BOOLEAN DEFAULT FALSE, pickup_arrived_at TIMESTAMPTZ, started_at TIMESTAMPTZ, completed_at TIMESTAMPTZ, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW(), payment_method TEXT, origin_address TEXT NOT NULL, destination_address TEXT NOT NULL);
CREATE TABLE IF NOT EXISTS public.ride_ratings (id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(), ride_id UUID NOT NULL, reviewer_id UUID NOT NULL, reviewee_id UUID NOT NULL, rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5), comment TEXT, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW());
CREATE TABLE IF NOT EXISTS public.driver_passenger_ratings (id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(), ride_id UUID NOT NULL, rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5), created_by UUID NOT NULL, comment TEXT, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW());
CREATE TABLE IF NOT EXISTS public.driver_payout_requests (id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(), driver_id UUID NOT NULL, amount NUMERIC NOT NULL, status public.payout_status DEFAULT 'pending', payment_method TEXT NOT NULL, payment_details JSONB NOT NULL, notes TEXT, admin_notes TEXT, processed_by UUID, processed_at TIMESTAMPTZ, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW());
CREATE TABLE IF NOT EXISTS public.driver_balances (driver_id UUID PRIMARY KEY, total_earnings NUMERIC DEFAULT 0, available NUMERIC DEFAULT 0, reserved NUMERIC DEFAULT 0, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW());
CREATE TABLE IF NOT EXISTS public.fee_payments (id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(), driver_id UUID NOT NULL, amount NUMERIC NOT NULL, status public.fee_status DEFAULT 'not_requested', initial_due_date TIMESTAMPTZ NOT NULL, payment_due_date TIMESTAMPTZ, paid_at TIMESTAMPTZ, canceled_at TIMESTAMPTZ, canceled_reason TEXT, available_balance_before NUMERIC DEFAULT 0, actual_fee_amount NUMERIC DEFAULT 0, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW());
CREATE TABLE IF NOT EXISTS public.chat_messages (id UUID PRIMARY KEY DEFAULT gen_random_uuid(), ride_id UUID NOT NULL, sender_id UUID NOT NULL, receiver_id UUID NOT NULL, text TEXT NOT NULL, delivered_at TIMESTAMPTZ, read_at TIMESTAMPTZ, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW());
CREATE TABLE IF NOT EXISTS public.subscription_plans (id UUID PRIMARY KEY DEFAULT gen_random_uuid(), name TEXT NOT NULL, duration_days INTEGER NOT NULL, price_cents INTEGER NOT NULL, is_active BOOLEAN DEFAULT TRUE, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW());
CREATE TABLE IF NOT EXISTS public.subscription_requests (id UUID PRIMARY KEY DEFAULT gen_random_uuid(), driver_id UUID NOT NULL, plan_id UUID NOT NULL, current_subscription_id UUID, status TEXT DEFAULT 'pending', requested_at TIMESTAMPTZ DEFAULT NOW(), processed_at TIMESTAMPTZ, processed_by UUID, admin_notes TEXT);
CREATE TABLE IF NOT EXISTS public.driver_subscriptions (id UUID PRIMARY KEY DEFAULT gen_random_uuid(), driver_id UUID NOT NULL, plan_id UUID NOT NULL, status public.subscription_status DEFAULT 'ativa', start_date TIMESTAMPTZ NOT NULL, end_date TIMESTAMPTZ NOT NULL, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW());
CREATE TABLE IF NOT EXISTS public.bd_ativo (id SERIAL PRIMARY KEY, num BIGINT NOT NULL, created_at TIMESTAMPTZ DEFAULT NOW());

-- Funções
CREATE OR REPLACE FUNCTION public.set_updated_at() RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ BEGIN IF NEW IS DISTINCT FROM OLD THEN NEW.updated_at = NOW(); END IF; RETURN NEW; END; $$;
CREATE OR REPLACE FUNCTION public.handle_new_user() RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ BEGIN INSERT INTO public.profiles (id, full_name, user_type, is_active, created_at, updated_at) VALUES (NEW.id, COALESCE(NEW.raw_user_meta_data->>'full_name', 'Usuário'), COALESCE(NEW.raw_user_meta_data->>'user_type', 'passenger'), CASE WHEN COALESCE(NEW.raw_user_meta_data->>'user_type', 'passenger') = 'driver' THEN FALSE ELSE TRUE END, NOW(), NOW()) ON CONFLICT (id) DO NOTHING; RETURN NEW; END; $$;
CREATE OR REPLACE FUNCTION public.inserir_3x_e_parar() RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ DECLARE i INT := 0; BEGIN WHILE i < 3 LOOP INSERT INTO bd_ativo(num) VALUES (1); i := i + 1; IF i < 3 THEN PERFORM pg_sleep(5); END IF; END LOOP; END; $$;
CREATE OR REPLACE FUNCTION public.calculate_driver_balance(p_driver_id uuid) RETURNS public.driver_balances LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ DECLARE v_total_earnings NUMERIC DEFAULT 0; v_reserved NUMERIC DEFAULT 0; v_available NUMERIC DEFAULT 0; v_balance public.driver_balances; BEGIN SELECT COALESCE(SUM(actual_price), 0) INTO v_total_earnings FROM public.rides WHERE driver_id = p_driver_id AND status = 'completed'; SELECT COALESCE(SUM(actual_fee_amount), 0) INTO v_reserved FROM public.fee_payments WHERE driver_id = p_driver_id AND status IN ('pending', 'expired'); v_available := v_total_earnings - v_reserved; IF v_available < 0 THEN v_available := 0; END IF; INSERT INTO public.driver_balances (driver_id, total_earnings, available, reserved) VALUES (p_driver_id, v_total_earnings, v_available, v_reserved) ON CONFLICT (driver_id) DO UPDATE SET total_earnings = EXCLUDED.total_earnings, available = EXCLUDED.available, reserved = EXCLUDED.reserved, updated_at = NOW() RETURNING * INTO v_balance; RETURN v_balance; END; $$;
CREATE OR REPLACE FUNCTION public.request_fee_payment() RETURNS public.fee_payments LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ DECLARE v_driver_id UUID; v_profile_created_at TIMESTAMPTZ; v_initial_deadline TIMESTAMPTZ; v_payment_deadline TIMESTAMPTZ; v_available_balance NUMERIC; v_service_fee_settings RECORD; v_service_fee_amount NUMERIC; v_fee_payment public.fee_payments; BEGIN v_driver_id := auth.uid(); IF v_driver_id IS NULL THEN RAISE EXCEPTION 'not_authenticated'; END IF; IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = v_driver_id AND user_type = 'driver') THEN RAISE EXCEPTION 'not_a_driver'; END IF; SELECT created_at INTO v_profile_created_at FROM public.profiles WHERE id = v_driver_id; v_initial_deadline := v_profile_created_at + INTERVAL '2 days'; IF NOW() > v_initial_deadline THEN RAISE EXCEPTION 'initial_deadline_expired'; END IF; IF EXISTS (SELECT 1 FROM public.fee_payments WHERE driver_id = v_driver_id AND status IN ('pending', 'expired')) THEN RAISE EXCEPTION 'active_fee_exists'; END IF; SELECT COALESCE(available, 0) INTO v_available_balance FROM public.driver_balances WHERE driver_id = v_driver_id; IF v_available_balance IS NULL THEN v_available_balance := 0; END IF; IF v_available_balance <= 0 THEN RAISE EXCEPTION 'no_available_funds'; END IF; SELECT service_fee_type, service_fee_value INTO v_service_fee_settings FROM public.pricing_settings ORDER BY created_at DESC LIMIT 1; IF v_service_fee_settings.service_fee_type = 'fixed' THEN v_service_fee_amount := COALESCE(v_service_fee_settings.service_fee_value, 0); ELSIF v_service_fee_settings.service_fee_type = 'percent' THEN v_service_fee_amount := v_available_balance * (COALESCE(v_service_fee_settings.service_fee_value, 0) / 100); ELSE v_service_fee_amount := 0; END IF; IF v_service_fee_amount <= 0 THEN RAISE EXCEPTION 'invalid_fee_amount'; END IF; IF v_available_balance < v_service_fee_amount THEN RAISE EXCEPTION 'insufficient_funds_for_fee'; END IF; v_payment_deadline := NOW() + INTERVAL '2 days'; INSERT INTO public.fee_payments (driver_id, amount, status, initial_due_date, payment_due_date, available_balance_before, actual_fee_amount) VALUES (v_driver_id, v_available_balance, 'pending', v_initial_deadline, v_payment_deadline, v_available_balance, v_service_fee_amount) RETURNING * INTO v_fee_payment; INSERT INTO public.driver_balances (driver_id, total_earnings, available, reserved) VALUES (v_driver_id, v_available_balance, 0, v_service_fee_amount) ON CONFLICT (driver_id) DO UPDATE SET available = v_available_balance - v_service_fee_amount, reserved = driver_balances.reserved + v_service_fee_amount, updated_at = NOW(); RETURN v_fee_payment; END; $$;
CREATE OR REPLACE FUNCTION public.mark_fee_paid(p_fee_id uuid) RETURNS public.fee_payments LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ DECLARE v_fee_payment public.fee_payments; v_current_user_id UUID; BEGIN v_current_user_id := auth.uid(); IF v_current_user_id IS NULL THEN RAISE EXCEPTION 'unauthorized'; END IF; IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = v_current_user_id AND user_type = 'admin') THEN RAISE EXCEPTION 'unauthorized'; END IF; SELECT * INTO v_fee_payment FROM public.fee_payments WHERE id = p_fee_id; IF NOT FOUND THEN RAISE EXCEPTION 'fee_not_found'; END IF; IF v_fee_payment.status != 'pending' THEN RAISE EXCEPTION 'invalid_status'; END IF; UPDATE public.fee_payments SET status = 'paid', paid_at = NOW(), updated_at = NOW() WHERE id = p_fee_id RETURNING * INTO v_fee_payment; UPDATE public.driver_balances SET reserved = reserved - v_fee_payment.actual_fee_amount, updated_at = NOW() WHERE driver_id = v_fee_payment.driver_id; RETURN v_fee_payment; END; $$;
CREATE OR REPLACE FUNCTION public.cancel_fee(p_fee_id uuid, p_reason text) RETURNS public.fee_payments LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ DECLARE v_fee_payment public.fee_payments; v_current_user_id UUID; BEGIN v_current_user_id := auth.uid(); IF v_current_user_id IS NULL THEN RAISE EXCEPTION 'unauthorized'; END IF; IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = v_current_user_id AND user_type = 'admin') THEN RAISE EXCEPTION 'unauthorized'; END IF; SELECT * INTO v_fee_payment FROM public.fee_payments WHERE id = p_fee_id; IF NOT FOUND THEN RAISE EXCEPTION 'fee_not_found'; END IF; IF v_fee_payment.status NOT IN ('pending', 'expired') THEN RAISE EXCEPTION 'invalid_status'; END IF; UPDATE public.fee_payments SET status = 'canceled', canceled_at = NOW(), canceled_reason = p_reason, updated_at = NOW() WHERE id = p_fee_id RETURNING * INTO v_fee_payment; UPDATE public.driver_balances SET available = available + v_fee_payment.actual_fee_amount, reserved = reserved - v_fee_payment.actual_fee_amount, updated_at = NOW() WHERE driver_id = v_fee_payment.driver_id; RETURN v_fee_payment; END; $$;
CREATE OR REPLACE FUNCTION public.request_subscription_renewal(p_plan_id uuid) RETURNS public.subscription_requests LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ DECLARE v_driver_id UUID; v_current_subscription RECORD; v_plan RECORD; v_request public.subscription_requests; BEGIN v_driver_id := auth.uid(); IF v_driver_id IS NULL THEN RAISE EXCEPTION 'not_authenticated'; END IF; IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = v_driver_id AND user_type = 'driver') THEN RAISE EXCEPTION 'not_a_driver'; END IF; IF EXISTS (SELECT 1 FROM public.subscription_requests WHERE driver_id = v_driver_id AND status = 'pending') THEN RAISE EXCEPTION 'pending_request_exists'; END IF; SELECT * INTO v_plan FROM public.subscription_plans WHERE id = p_plan_id AND is_active = true; IF NOT FOUND THEN RAISE EXCEPTION 'invalid_plan'; END IF; SELECT * INTO v_current_subscription FROM public.driver_subscriptions WHERE driver_id = v_driver_id ORDER BY created_at DESC LIMIT 1; INSERT INTO public.subscription_requests (driver_id, plan_id, current_subscription_id, status) VALUES (v_driver_id, p_plan_id, v_current_subscription.id, 'pending') RETURNING * INTO v_request; RETURN v_request; END; $$;
CREATE OR REPLACE FUNCTION public.approve_subscription_payment(p_request_id uuid) RETURNS public.driver_subscriptions LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ DECLARE v_admin_id UUID; v_request RECORD; v_plan RECORD; v_current_subscription RECORD; v_start_date TIMESTAMPTZ; v_end_date TIMESTAMPTZ; v_new_subscription public.driver_subscriptions; BEGIN v_admin_id := auth.uid(); IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = v_admin_id AND user_type = 'admin') THEN RAISE EXCEPTION 'unauthorized'; END IF; SELECT * INTO v_request FROM public.subscription_requests WHERE id = p_request_id; IF NOT FOUND THEN RAISE EXCEPTION 'request_not_found'; END IF; IF v_request.status != 'pending' THEN RAISE EXCEPTION 'invalid_request_status'; END IF; SELECT * INTO v_plan FROM public.subscription_plans WHERE id = v_request.plan_id; SELECT * INTO v_current_subscription FROM public.driver_subscriptions WHERE driver_id = v_request.driver_id ORDER BY created_at DESC LIMIT 1; IF v_current_subscription.id IS NOT NULL AND v_current_subscription.end_date > NOW() THEN v_start_date := v_current_subscription.end_date; v_end_date := v_current_subscription.end_date + (v_plan.duration_days || ' days')::interval; ELSE v_start_date := NOW(); v_end_date := NOW() + (v_plan.duration_days || ' days')::interval; END IF; INSERT INTO public.driver_subscriptions (driver_id, plan_id, status, start_date, end_date) VALUES (v_request.driver_id, v_request.plan_id, 'ativa', v_start_date, v_end_date) RETURNING * INTO v_new_subscription; UPDATE public.subscription_requests SET status = 'approved', processed_at = NOW(), processed_by = v_admin_id WHERE id = p_request_id; IF v_current_subscription.id IS NOT NULL THEN UPDATE public.driver_subscriptions SET status = 'vencida' WHERE id = v_current_subscription.id; END IF; RETURN v_new_subscription; END; $$;
CREATE OR REPLACE FUNCTION public.get_driver_subscription_status(p_driver_id uuid) RETURNS TABLE(subscription_id uuid, plan_name text, duration_days integer, price_cents integer, status subscription_status, start_date timestamp with time zone, end_date timestamp with time zone, days_remaining integer, has_pending_request boolean) LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ BEGIN RETURN QUERY SELECT ds.id, sp.name, sp.duration_days, sp.price_cents, CASE WHEN ds.end_date < NOW() THEN 'vencida'::subscription_status ELSE ds.status END, ds.start_date, ds.end_date, GREATEST(0, EXTRACT(DAY FROM ds.end_date - NOW())::INTEGER), EXISTS(SELECT 1 FROM public.subscription_requests sr WHERE sr.driver_id = p_driver_id AND sr.status = 'pending') FROM public.driver_subscriptions ds JOIN public.subscription_plans sp ON sp.id = ds.plan_id WHERE ds.driver_id = p_driver_id ORDER BY ds.created_at DESC LIMIT 1; END; $$;

-- Índices
CREATE UNIQUE INDEX IF NOT EXISTS locations_user_id_key ON public.locations(user_id);
CREATE INDEX IF NOT EXISTS idx_locations_user_time ON public.locations(user_id, timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_rides_passenger ON public.rides(passenger_id);
CREATE INDEX IF NOT EXISTS idx_rides_driver ON public.rides(driver_id);
CREATE INDEX IF NOT EXISTS idx_rides_status ON public.rides(status);
CREATE UNIQUE INDEX IF NOT EXISTS one_pricing_row ON public.pricing_settings (singleton) WHERE singleton;

-- RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admin_setup ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.driver_details ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.pricing_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.locations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.rides ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ride_ratings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.driver_passenger_ratings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.driver_payout_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.driver_balances ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.fee_payments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.chat_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscription_plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscription_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.driver_subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bd_ativo ENABLE ROW LEVEL SECURITY;

-- Políticas (usando policyname)
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename='profiles' AND policyname='Users can insert their own profile') THEN CREATE POLICY "Users can insert their own profile" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename='profiles' AND policyname='Users can update their own profile') THEN CREATE POLICY "Users can update their own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename='profiles' AND policyname='Users can view all profiles') THEN CREATE POLICY "Users can view all profiles" ON public.profiles FOR SELECT USING (TRUE); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename='profiles' AND policyname='Admins can update any profile') THEN CREATE POLICY "Admins can update any profile" ON public.profiles FOR UPDATE USING (EXISTS (SELECT 1 FROM public.profiles p WHERE p.id = auth.uid() AND p.user_type = 'admin')); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Admins can manage admin_setup') THEN CREATE POLICY "Admins can manage admin_setup" ON public.admin_setup FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_type = 'admin')); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Drivers can manage their own details') THEN CREATE POLICY "Drivers can manage their own details" ON public.driver_details FOR ALL USING (user_id = auth.uid()); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Admins can view all driver details') THEN CREATE POLICY "Admins can view all driver details" ON public.driver_details FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_type = 'admin')); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Passengers can view driver details during active rides') THEN CREATE POLICY "Passengers can view driver details during active rides" ON public.driver_details FOR SELECT USING (EXISTS (SELECT 1 FROM public.rides WHERE driver_id = driver_details.user_id AND passenger_id = auth.uid() AND status IN ('accepted', 'in_progress'))); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Admins can manage pricing settings') THEN CREATE POLICY "Admins can manage pricing settings" ON public.pricing_settings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_type = 'admin')); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Everyone can view pricing settings') THEN CREATE POLICY "Everyone can view pricing settings" ON public.pricing_settings FOR SELECT USING (TRUE); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Users can manage their own location') THEN CREATE POLICY "Users can manage their own location" ON public.locations FOR ALL USING (user_id = auth.uid()); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Users can view locations for active rides') THEN CREATE POLICY "Users can view locations for active rides" ON public.locations FOR SELECT USING (EXISTS (SELECT 1 FROM public.rides WHERE ((passenger_id = auth.uid()) OR (driver_id = auth.uid())) AND status IN ('accepted', 'in_progress') AND ((driver_id = locations.user_id) OR (passenger_id = locations.user_id)))); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Admins can view all rides') THEN CREATE POLICY "Admins can view all rides" ON public.rides FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_type = 'admin')); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Passengers can create rides') THEN CREATE POLICY "Passengers can create rides" ON public.rides FOR INSERT WITH CHECK (passenger_id = auth.uid()); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Users can view their rides') THEN CREATE POLICY "Users can view their rides" ON public.rides FOR SELECT USING ((passenger_id = auth.uid()) OR (driver_id = auth.uid())); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Users can update their rides') THEN CREATE POLICY "Users can update their rides" ON public.rides FOR UPDATE USING ((passenger_id = auth.uid()) OR (driver_id = auth.uid()) OR ((driver_id IS NULL) AND (status = 'pending'))); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Drivers can view pending rides') THEN CREATE POLICY "Drivers can view pending rides" ON public.rides FOR SELECT USING ((status = 'pending') AND (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_type = 'driver'))); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Users can manage ratings for their rides') THEN CREATE POLICY "Users can manage ratings for their rides" ON public.ride_ratings FOR ALL USING ((reviewer_id = auth.uid()) OR (reviewee_id = auth.uid())); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Users can manage driver passenger ratings') THEN CREATE POLICY "Users can manage driver passenger ratings" ON public.driver_passenger_ratings FOR ALL USING ((created_by = auth.uid()) OR (EXISTS (SELECT 1 FROM public.rides WHERE id = driver_passenger_ratings.ride_id AND ((passenger_id = auth.uid()) OR (driver_id = auth.uid()))))); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Drivers can manage their payout requests') THEN CREATE POLICY "Drivers can manage their payout requests" ON public.driver_payout_requests FOR ALL USING (driver_id = auth.uid()); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Admins can view all payout requests') THEN CREATE POLICY "Admins can view all payout requests" ON public.driver_payout_requests FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_type = 'admin')); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Drivers can view their own balance') THEN CREATE POLICY "Drivers can view their own balance" ON public.driver_balances FOR SELECT USING (driver_id = auth.uid()); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='System can manage driver balances') THEN CREATE POLICY "System can manage driver balances" ON public.driver_balances FOR ALL USING (TRUE); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Drivers can view their own fee payments') THEN CREATE POLICY "Drivers can view their own fee payments" ON public.fee_payments FOR SELECT USING (driver_id = auth.uid()); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Admins can manage fee payments') THEN CREATE POLICY "Admins can manage fee payments" ON public.fee_payments FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_type = 'admin')); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='System can manage fee payments') THEN CREATE POLICY "System can manage fee payments" ON public.fee_payments FOR ALL USING (TRUE); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Users can view messages from their rides') THEN CREATE POLICY "Users can view messages from their rides" ON public.chat_messages FOR SELECT USING (EXISTS (SELECT 1 FROM public.rides WHERE id = chat_messages.ride_id AND ((passenger_id = auth.uid()) OR (driver_id = auth.uid())))); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Users can send messages in their rides') THEN CREATE POLICY "Users can send messages in their rides" ON public.chat_messages FOR INSERT WITH CHECK ((sender_id = auth.uid()) AND (EXISTS (SELECT 1 FROM public.rides WHERE id = chat_messages.ride_id AND ((passenger_id = auth.uid()) OR (driver_id = auth.uid())))) AND (EXISTS (SELECT 1 FROM public.rides WHERE id = chat_messages.ride_id AND ((passenger_id = chat_messages.receiver_id) OR (driver_id = chat_messages.receiver_id))))); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Users can update messages sent to them') THEN CREATE POLICY "Users can update messages sent to them" ON public.chat_messages FOR UPDATE USING (receiver_id = auth.uid()) WITH CHECK (receiver_id = auth.uid()); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Everyone can view active subscription plans') THEN CREATE POLICY "Everyone can view active subscription plans" ON public.subscription_plans FOR SELECT USING (is_active = TRUE); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Admins can manage subscription plans') THEN CREATE POLICY "Admins can manage subscription plans" ON public.subscription_plans FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_type = 'admin')); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Drivers can create and view their own subscription requests') THEN CREATE POLICY "Drivers can create and view their own subscription requests" ON public.subscription_requests FOR ALL USING (driver_id = auth.uid()); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Admins can view and manage all subscription requests') THEN CREATE POLICY "Admins can view and manage all subscription requests" ON public.subscription_requests FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_type = 'admin')); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Drivers can view their own subscriptions') THEN CREATE POLICY "Drivers can view their own subscriptions" ON public.driver_subscriptions FOR SELECT USING (driver_id = auth.uid()); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Admins can view all driver subscriptions') THEN CREATE POLICY "Admins can view all driver subscriptions" ON public.driver_subscriptions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_type = 'admin')); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='System can manage driver subscriptions') THEN CREATE POLICY "System can manage driver subscriptions" ON public.driver_subscriptions FOR ALL USING (TRUE); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='System can insert bd_ativo records') THEN CREATE POLICY "System can insert bd_ativo records" ON public.bd_ativo FOR INSERT WITH CHECK (TRUE); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname='Admins can view all bd_ativo records') THEN CREATE POLICY "Admins can view all bd_ativo records" ON public.bd_ativo FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_type = 'admin')); END IF; END $$;

-- Triggers
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user(); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'profiles_set_updated_at') THEN CREATE TRIGGER profiles_set_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.set_updated_at(); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'admin_setup_set_updated_at') THEN CREATE TRIGGER admin_setup_set_updated_at BEFORE UPDATE ON public.admin_setup FOR EACH ROW EXECUTE FUNCTION public.set_updated_at(); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='driver_details_set_updated_at') THEN CREATE TRIGGER driver_details_set_updated_at BEFORE UPDATE ON public.driver_details FOR EACH ROW EXECUTE FUNCTION public.set_updated_at(); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='pricing_settings_set_updated_at') THEN CREATE TRIGGER pricing_settings_set_updated_at BEFORE UPDATE ON public.pricing_settings FOR EACH ROW EXECUTE FUNCTION public.set_updated_at(); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='rides_set_updated_at') THEN CREATE TRIGGER rides_set_updated_at BEFORE UPDATE ON public.rides FOR EACH ROW EXECUTE FUNCTION public.set_updated_at(); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='ride_ratings_set_updated_at') THEN CREATE TRIGGER ride_ratings_set_updated_at BEFORE UPDATE ON public.ride_ratings FOR EACH ROW EXECUTE FUNCTION public.set_updated_at(); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='driver_passenger_ratings_set_updated_at') THEN CREATE TRIGGER driver_passenger_ratings_set_updated_at BEFORE UPDATE ON public.driver_passenger_ratings FOR EACH ROW EXECUTE FUNCTION public.set_updated_at(); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='driver_payout_requests_set_updated_at') THEN CREATE TRIGGER driver_payout_requests_set_updated_at BEFORE UPDATE ON public.driver_payout_requests FOR EACH ROW EXECUTE FUNCTION public.set_updated_at(); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='driver_balances_set_updated_at') THEN CREATE TRIGGER driver_balances_set_updated_at BEFORE UPDATE ON public.driver_balances FOR EACH ROW EXECUTE FUNCTION public.set_updated_at(); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='fee_payments_set_updated_at') THEN CREATE TRIGGER fee_payments_set_updated_at BEFORE UPDATE ON public.fee_payments FOR EACH ROW EXECUTE FUNCTION public.set_updated_at(); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='chat_messages_set_updated_at') THEN CREATE TRIGGER chat_messages_set_updated_at BEFORE UPDATE ON public.chat_messages FOR EACH ROW EXECUTE FUNCTION public.set_updated_at(); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='subscription_plans_set_updated_at') THEN CREATE TRIGGER subscription_plans_set_updated_at BEFORE UPDATE ON public.subscription_plans FOR EACH ROW EXECUTE FUNCTION public.set_updated_at(); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='driver_subscriptions_set_updated_at') THEN CREATE TRIGGER driver_subscriptions_set_updated_at BEFORE UPDATE ON public.driver_subscriptions FOR EACH ROW EXECUTE FUNCTION public.set_updated_at(); END IF; END $$;

-- Realtime
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_publication_tables WHERE pubname = 'supabase_realtime' AND tablename = 'locations') THEN ALTER PUBLICATION supabase_realtime ADD TABLE public.locations; END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_publication_tables WHERE pubname = 'supabase_realtime' AND tablename = 'rides') THEN ALTER PUBLICATION supabase_realtime ADD TABLE public.rides; END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_publication_tables WHERE pubname = 'supabase_realtime' AND tablename = 'chat_messages') THEN ALTER PUBLICATION supabase_realtime ADD TABLE public.chat_messages; END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_publication_tables WHERE pubname = 'supabase_realtime' AND tablename = 'driver_balances') THEN ALTER PUBLICATION supabase_realtime ADD TABLE public.driver_balances; END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_publication_tables WHERE pubname = 'supabase_realtime' AND tablename = 'fee_payments') THEN ALTER PUBLICATION supabase_realtime ADD TABLE public.fee_payments; END IF; END $$;

-- Storage
INSERT INTO storage.buckets (id, name, public) SELECT 'avatars', 'avatars', true WHERE NOT EXISTS (SELECT 1 FROM storage.buckets WHERE id = 'avatars');
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname = 'storage' AND policyname = 'Avatar images are publicly accessible') THEN CREATE POLICY "Avatar images are publicly accessible" ON storage.objects FOR SELECT USING (bucket_id = 'avatars'); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname = 'storage' AND policyname = 'Users can upload their own avatar') THEN CREATE POLICY "Users can upload their own avatar" ON storage.objects FOR INSERT WITH CHECK (bucket_id = 'avatars' AND auth.uid()::text = (storage.foldername(name))[1]); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname = 'storage' AND policyname = 'Users can update their own avatar') THEN CREATE POLICY "Users can update their own avatar" ON storage.objects FOR UPDATE USING (bucket_id = 'avatars' AND auth.uid()::text = (storage.foldername(name))[1]); END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname = 'storage' AND policyname = 'Users can delete their own avatar') THEN CREATE POLICY "Users can delete their own avatar" ON storage.objects FOR DELETE USING (bucket_id = 'avatars' AND auth.uid()::text = (storage.foldername(name))[1]); END IF; END $$;

-- Cron
SELECT cron.unschedule('projetoAtivo') WHERE EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'projetoAtivo');
SELECT cron.schedule('projetoAtivo', '0 0 */5 * *', 'SELECT public.inserir_3x_e_parar();');

-- Seed Data
INSERT INTO public.pricing_settings (price_per_km, fixed_price, price_per_km_active, fixed_price_active, service_fee_type, service_fee_value, singleton) SELECT 2.50, NULL, TRUE, FALSE, 'fixed', 0, TRUE WHERE NOT EXISTS (SELECT 1 FROM public.pricing_settings);
INSERT INTO public.admin_setup (admin_user_id, password_set) SELECT '00000000-0000-0000-0000-000000000000', FALSE WHERE NOT EXISTS (SELECT 1 FROM public.admin_setup);